[{"title":"20200621170045","url":"/zh-cn/2020/6/6/20200621170045.html","content":"<p>test </p>\n","categories":["未分类"],"tags":["记录"]},{"title":"Linux常用命令参考","url":"/zh-cn/2016/9/9/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83.html","content":"<p>记录Linux常用命令及用法，随便写写，加深记忆，自用备查。</p>\n<h2 id=\"一、文件压缩和打包\"><a href=\"#一、文件压缩和打包\" class=\"headerlink\" title=\"一、文件压缩和打包\"></a>一、文件压缩和打包</h2><h3 id=\"1-gzip-gunzip\"><a href=\"#1-gzip-gunzip\" class=\"headerlink\" title=\"1. gzip/gunzip\"></a>1. gzip/gunzip</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root]<span class=\"comment\"># gzip filename.ext</span></span><br><span class=\"line\">[root]<span class=\"comment\"># ls -l</span></span><br><span class=\"line\">filename.ext.gz</span><br><span class=\"line\">[root]<span class=\"comment\"># gunzip filename.ext.gz</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-tar\"><a href=\"#2-tar\" class=\"headerlink\" title=\"2. tar\"></a>2. tar</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[root]#</span><span class=\"bash\"> tar -czvf boot.tgz /boot</span></span><br><span class=\"line\"><span class=\"meta\">[root]#</span><span class=\"bash\"> tar -zxvf boot.tgz -C /tmp</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-bizp2\"><a href=\"#3-bizp2\" class=\"headerlink\" title=\"3. bizp2\"></a>3. bizp2</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">bzip2 intall.log</span><br><span class=\"line\">ls insatll.log.bz2</span><br><span class=\"line\">insatll.log.bz2</span><br><span class=\"line\">bzip2 -d insatll.log.bz2</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-cpio\"><a href=\"#4-cpio\" class=\"headerlink\" title=\"4. cpio\"></a>4. cpio</h3><ul>\n<li>备份<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[root]#</span><span class=\"bash\"> find /etc -name *.conf | cpio -cov &gt; /tmp/conf.cpio</span></span><br></pre></td></tr></table></figure></li>\n<li>还原<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">[root]#</span><span class=\"bash\"> cpio --absolute-filenames -icvu &lt; /tmp/conf.cpio</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"二、文件系统\"><a href=\"#二、文件系统\" class=\"headerlink\" title=\"二、文件系统\"></a>二、文件系统</h2><h3 id=\"1-分区\"><a href=\"#1-分区\" class=\"headerlink\" title=\"1. 分区\"></a>1. 分区</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">fdisk -l</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-磁盘挂载\"><a href=\"#2-磁盘挂载\" class=\"headerlink\" title=\"2. 磁盘挂载\"></a>2. 磁盘挂载</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mount DEVICE MOUNT_POINT</span><br><span class=\"line\">mkdir newDisk</span><br><span class=\"line\">mount &#x2F;dev&#x2F;sdb1 newDisk</span><br><span class=\"line\">mount  --显示所有挂载</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-解除挂载\"><a href=\"#3-解除挂载\" class=\"headerlink\" title=\"3. 解除挂载\"></a>3. 解除挂载</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">umount DEVICE&#x2F;PATH</span><br><span class=\"line\">or</span><br><span class=\"line\">umount MOUNT_POINT</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-查看可用空间\"><a href=\"#4-查看可用空间\" class=\"headerlink\" title=\"4. 查看可用空间\"></a>4. 查看可用空间</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">df -h</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-设置启动自动挂载：-etc-fstab\"><a href=\"#5-设置启动自动挂载：-etc-fstab\" class=\"headerlink\" title=\"5. 设置启动自动挂载： /etc/fstab\"></a>5. 设置启动自动挂载： /etc/fstab</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo \"/dev/sdb1 /root/newDisk ext3 defaults 0 0\" &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure>\n<p>此命令将/dev/sdb1挂载到/root/newDisk目录，defaults表示默认挂载，第一个0代表dump时此分区不存档，第二个0表示系统启动时不对此分区进行fsck（1给根分区用，2检查完根分区后检查）</p>\n<h3 id=\"6-磁盘检查：fsck\"><a href=\"#6-磁盘检查：fsck\" class=\"headerlink\" title=\"6. 磁盘检查：fsck\"></a>6. 磁盘检查：fsck</h3><p>磁盘错误可以用fsck尝试修复：（<strong>磁盘必须是未挂载状态，否则会造成文件系统损坏</strong>）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">fsck -t TYPE /DEVICE/PATH</span><br><span class=\"line\">fsck -t ext3 /dev/sdb1</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、逻辑卷\"><a href=\"#三、逻辑卷\" class=\"headerlink\" title=\"三、逻辑卷\"></a>三、逻辑卷</h2><h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1. 概念\"></a>1. 概念</h3><ul>\n<li>物理卷（PV），物理分区</li>\n<li>卷组（VG），PV的集合</li>\n<li>逻辑卷（LV），PV中划出来的一块逻辑磁盘</li>\n</ul>\n<h3 id=\"2-制作逻辑卷\"><a href=\"#2-制作逻辑卷\" class=\"headerlink\" title=\"2. 制作逻辑卷\"></a>2. 制作逻辑卷</h3><p>1.将磁盘分区创建为物理卷（<strong>分区格式必须是8e</strong>）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">fdisk &#x2F;dev&#x2F;sdb</span><br><span class=\"line\">pvcreate &#x2F;dev&#x2F;sdb1</span><br><span class=\"line\">pvcreate &#x2F;dev&#x2F;sdb2</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>2.查看物理卷信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">pvscan or pvdisplay</span><br></pre></td></tr></table></figure>\n<p>3.创建并查询卷组</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">vgcreate VG_NAME DEVICE1 ... DEVICEn //创建</span><br><span class=\"line\">vgscan or vgdisplay        //查询所有</span><br></pre></td></tr></table></figure>\n<p>4.扩容卷组</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">vgextend VG_NAME DEVICE1 ... DEVICEn</span><br></pre></td></tr></table></figure>\n<p>5.创建逻辑卷</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">lvcreate -L SIZE -n LV_NAME VG_NAME</span><br><span class=\"line\">lvdisplay</span><br></pre></td></tr></table></figure>\n<p>6.创建文件系统并挂载</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkfs ext3 LV_NAME</span><br><span class=\"line\">mkdir MOUNT_POINT</span><br><span class=\"line\">mount DEVICE MOUNT_POINT</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、文件链接\"><a href=\"#四、文件链接\" class=\"headerlink\" title=\"四、文件链接\"></a>四、文件链接</h2><h3 id=\"1-硬链接\"><a href=\"#1-硬链接\" class=\"headerlink\" title=\"1. 硬链接\"></a>1. 硬链接</h3><p>Linux中所有的文件都会有一个编号，称为inode，多个文件名指向同一索引节点是被允许的，这种链接叫硬链接，当最后一个链接被删除时，文件的数据块才被释放。<br>硬链接有两个限制：</p>\n<ul>\n<li>不允许给目录创建硬链接</li>\n<li>只有在同一文件系统内的文件之间才能创建硬链接，即不同分区上的两个文件之间不能建立硬链接<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ln TARGET_FILE LINK_NAME</span><br><span class=\"line\">ls -li     //查看inode信息（链接数加一）</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"2-软链接\"><a href=\"#2-软链接\" class=\"headerlink\" title=\"2. 软链接\"></a>2. 软链接</h3><p>软链接称为符号链接，是一个包含了另一个文件路径的文件，可以指向任意文件或目录，也可以跨不同的文件系统。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ln -s TARGET_FILE LINK_NAME</span><br><span class=\"line\">ls -li     //查看inode信息（链接数不变）</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、实用命令\"><a href=\"#五、实用命令\" class=\"headerlink\" title=\"五、实用命令\"></a>五、实用命令</h2><h3 id=\"grep-搜索文本\"><a href=\"#grep-搜索文本\" class=\"headerlink\" title=\"grep 搜索文本\"></a>grep 搜索文本</h3><p><code>grep -ivnc &#39;express&#39; filename</code></p>\n<ul>\n<li><code>-i</code> 不区分大小写</li>\n<li><code>-c</code> 统计包含匹配的行数</li>\n<li><code>-n</code> 输出行号</li>\n<li><code>-v</code> 反向匹配</li>\n</ul>\n<h3 id=\"gpasswd-添加用户到组\"><a href=\"#gpasswd-添加用户到组\" class=\"headerlink\" title=\"gpasswd 添加用户到组\"></a>gpasswd 添加用户到组</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">gpasswd -a demo sudo &#x2F;&#x2F;将用户加入sudo组</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Ubuntu-启用root\"><a href=\"#Ubuntu-启用root\" class=\"headerlink\" title=\"Ubuntu 启用root\"></a>Ubuntu 启用root</h3><p>启用root用户或密码重设：<br>sudo passwd root</p>\n<p>临时切换命令如下：<br>sudo -s -H</p>\n<p>关闭root帐户<br>sudo passwd -l root</p>\n<h3 id=\"安装telnet\"><a href=\"#安装telnet\" class=\"headerlink\" title=\"安装telnet\"></a>安装telnet</h3><p>sudo apt-get install xinetd telnetd</p>\n<h2 id=\"六、实用工具\"><a href=\"#六、实用工具\" class=\"headerlink\" title=\"六、实用工具\"></a>六、实用工具</h2><h3 id=\"ufw防火墙\"><a href=\"#ufw防火墙\" class=\"headerlink\" title=\"ufw防火墙\"></a>ufw防火墙</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install ufw</span><br><span class=\"line\">sudo ufw allow ssh</span><br><span class=\"line\">sudo ufw allow 4444/tcp</span><br><span class=\"line\">sudo ufw allow 80/tcp</span><br><span class=\"line\">sudo ufw allow 443/tcp</span><br><span class=\"line\">sudo ufw status</span><br><span class=\"line\">sudo ufw -h</span><br><span class=\"line\">sudo ufw show added</span><br><span class=\"line\">sudo ufw <span class=\"built_in\">enable</span></span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZGlnaXRhbG9jZWFuLmNvbS9jb21tdW5pdHkvdHV0b3JpYWxzL2hvdy10by1zZXR1cC1hLWZpcmV3YWxsLXdpdGgtdWZ3LW9uLWFuLXVidW50dS1hbmQtZGViaWFuLWNsb3VkLXNlcnZlcg==\">进一步学习<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"设置NTP时间同步服务\"><a href=\"#设置NTP时间同步服务\" class=\"headerlink\" title=\"设置NTP时间同步服务\"></a>设置NTP时间同步服务</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo dpkg-reconfigure tzdata &#x2F;&#x2F;配置时区</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install ntp &#x2F;&#x2F;安装ntp服务</span><br></pre></td></tr></table></figure>\n<h3 id=\"nc测试udp端口\"><a href=\"#nc测试udp端口\" class=\"headerlink\" title=\"nc测试udp端口\"></a>nc测试udp端口</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nc -vuz 42.11.12.13 123</span><br><span class=\"line\">Connection to 42.11.12.13 123 port [udp&#x2F;ntp] succeeded!</span><br></pre></td></tr></table></figure>\n<p>nc命令用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">usage: nc [-46DdhklnrStUuvzC] [-i interval] [-p source_port]</span><br><span class=\"line\">[-s source_ip_address] [-T ToS] [-w timeout] [-X proxy_version]</span><br><span class=\"line\">[-x proxy_address[:port]] [hostname] [port[s]]</span><br></pre></td></tr></table></figure>\n","categories":["技术笔记"],"tags":["Linux"]},{"title":"Linux正则表达式","url":"/zh-cn/2017/4/4/Linux%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html","content":"<h1 id=\"一、基础正则表达式\"><a href=\"#一、基础正则表达式\" class=\"headerlink\" title=\"一、基础正则表达式\"></a>一、基础正则表达式</h1><h2 id=\"1、-点符号\"><a href=\"#1、-点符号\" class=\"headerlink\" title=\"1、. 点符号\"></a>1、<code>.</code> 点符号</h2><p>匹配除换行符之外的的任意一个字符<br>例如：r.t 匹配 rot ， rut等<br>r..t 匹配 root, ruut, rt(中间两个空格)</p>\n<h2 id=\"2、-星符号\"><a href=\"#2、-星符号\" class=\"headerlink\" title=\"2、* 星符号\"></a>2、<code>*</code> 星符号</h2><p>匹配前一个字符0次或任意多次<br>例如：ab* 匹配 a，ab，abb等<br>      <code>.*</code> 代表任意长度的不包含换换的字符<br>注意：<strong><em><code>g*d</code> g可能匹配0项</em></strong>      </p>\n<h2 id=\"3、-n-m-符号\"><a href=\"#3、-n-m-符号\" class=\"headerlink\" title=\"3、\\{n,m\\} 符号\"></a>3、<code>\\{n,m\\}</code> 符号</h2><p>精确匹配前一个字符的重复次数<br><code>\\{n\\}</code> 匹配前面的字符n次<br><code>\\{n,\\}</code> 匹配前面的字符n次以上,含n次<br><code>\\{n,m\\}</code> 匹配前面的字符n到m次<br>注意：<strong><em>egrep下，不能输入“\\”符号</em></strong></p>\n<h2 id=\"4、-符号\"><a href=\"#4、-符号\" class=\"headerlink\" title=\"4、^ 符号\"></a>4、<code>^</code> 符号</h2><p>匹配开头字符<br>例如：<code>^root</code> 匹配以root开头的行</p>\n<h2 id=\"5、-符号\"><a href=\"#5、-符号\" class=\"headerlink\" title=\"5、$ 符号\"></a>5、<code>$</code> 符号</h2><p>匹配行尾</p>\n<h2 id=\"6、-符号\"><a href=\"#6、-符号\" class=\"headerlink\" title=\"6、[] 符号\"></a>6、<code>[]</code> 符号</h2><p>匹配方括号内出现的任一字符，如果范围比较大，可以使用‘-’号进行范围限定，如[A-Z]匹配任意大写字符,[A-Za-z0-9]匹配任意字符和数字。<br>‘[]’内出现’^’符号代表取反,代表不是</p>\n<h2 id=\"7、-符号\"><a href=\"#7、-符号\" class=\"headerlink\" title=\"7、\\ 符号\"></a>7、<code>\\</code> 符号</h2><p>转义字符<br>例如：<code>\\.*</code> 代表匹配任意长度的’.’,而不是任意字符</p>\n<h2 id=\"8、-lt-和-gt-符号\"><a href=\"#8、-lt-和-gt-符号\" class=\"headerlink\" title=\"8、\\&lt; 和 \\&gt; 符号\"></a>8、<code>\\&lt;</code> 和 <code>\\&gt;</code> 符号</h2><p>分别界定单词的左边和右边<br>例如:<code>\\&lt;hello\\&gt;</code>精确匹配hello,而不是helloworld</p>\n<h2 id=\"9、-d-符号\"><a href=\"#9、-d-符号\" class=\"headerlink\" title=\"9、\\d 符号\"></a>9、<code>\\d</code> 符号</h2><p>匹配一个数字,等价于<code>[0-9]</code><br>注意:<code>\\d</code>有时有兼容性问题,如:<code>echo 123 | grep &#39;\\d&#39;</code><br>匹配不成功是因为<code>\\d</code>是一种Perl兼容模式的表达式,这种情况下要加上<code>-P</code>参数:<code>echo 123 | grep -P &#39;\\d&#39;</code></p>\n<h2 id=\"10、-b-符号\"><a href=\"#10、-b-符号\" class=\"headerlink\" title=\"10、\\b 符号\"></a>10、<code>\\b</code> 符号</h2><p>匹配单词边界，等价于<code>\\&lt;\\&gt;</code></p>\n<h2 id=\"11、-B-符号\"><a href=\"#11、-B-符号\" class=\"headerlink\" title=\"11、\\B 符号\"></a>11、<code>\\B</code> 符号</h2><p>匹配非单词的边界<br>例如:<code>hello\\B</code> 匹配 helloworld,即hello后必须有字符</p>\n<h2 id=\"12、-w-符号\"><a href=\"#12、-w-符号\" class=\"headerlink\" title=\"12、\\w 符号\"></a>12、<code>\\w</code> 符号</h2><p>匹配字母,数字和下划线,等价于<code>[A-Za-z0-9]</code><br>注意：比后者多匹配下划线</p>\n<h2 id=\"13、-W-符号\"><a href=\"#13、-W-符号\" class=\"headerlink\" title=\"13、\\W 符号\"></a>13、<code>\\W</code> 符号</h2><p>匹配非字母,数字和下划线<br>如：<code>@$%*^~\\&amp;#{}[]()&lt;&gt;+-/</code>等</p>\n<h2 id=\"14、-n-符号\"><a href=\"#14、-n-符号\" class=\"headerlink\" title=\"14、\\n 符号\"></a>14、<code>\\n</code> 符号</h2><p>匹配一个换换符</p>\n<h2 id=\"15、-r-符号\"><a href=\"#15、-r-符号\" class=\"headerlink\" title=\"15、\\r 符号\"></a>15、<code>\\r</code> 符号</h2><p>匹配一个回车符</p>\n<h2 id=\"16、-t-符号\"><a href=\"#16、-t-符号\" class=\"headerlink\" title=\"16、\\t 符号\"></a>16、<code>\\t</code> 符号</h2><p>匹配一个制表符</p>\n<h2 id=\"17、-f-符号\"><a href=\"#17、-f-符号\" class=\"headerlink\" title=\"17、\\f 符号\"></a>17、<code>\\f</code> 符号</h2><p>匹配一个换页符</p>\n<h2 id=\"18、-s-符号\"><a href=\"#18、-s-符号\" class=\"headerlink\" title=\"18、\\s 符号\"></a>18、<code>\\s</code> 符号</h2><p>匹配任何空白字符</p>\n<h2 id=\"19、-S-符号\"><a href=\"#19、-S-符号\" class=\"headerlink\" title=\"19、\\S 符号\"></a>19、<code>\\S</code> 符号</h2><p>匹配任何非空白字符<br>例如：<code>^\\b\\S+\\b\\s+\\b\\S+\\b\\s*$</code> 精确匹配两个单词（egrep）</p>\n<h1 id=\"二、扩展的正则表达式\"><a href=\"#二、扩展的正则表达式\" class=\"headerlink\" title=\"二、扩展的正则表达式\"></a>二、扩展的正则表达式</h1><p>以下这些必须要用egrep执行</p>\n<h2 id=\"1、-符号\"><a href=\"#1、-符号\" class=\"headerlink\" title=\"1、? 符号\"></a>1、<code>?</code> 符号</h2><p>匹配前一个字符0次或1次</p>\n<h2 id=\"2、-符号\"><a href=\"#2、-符号\" class=\"headerlink\" title=\"2、+ 符号\"></a>2、<code>+</code> 符号</h2><p>匹配前一个字符1次以上</p>\n<h2 id=\"3、-符号\"><a href=\"#3、-符号\" class=\"headerlink\" title=\"3、| 符号\"></a>3、<code>|</code> 符号</h2><p>“或”的意思，多种可能的罗列，彼此间是分支关系<br>例如：匹配不同的固定电话区号：<br><code>^0[0-9]\\{2,3\\}-[0-9]\\{8\\}</code><br>也可以这样写:<code>^0[0-9]\\{2\\}-[0-9]\\{8\\}|^0[0-9]\\{3\\}-[0-9]\\{8\\}</code><br>    021-38749087<br>    0556-34538979<br>    010 66508749<br>    01066508749</p>\n<h2 id=\"4、-符号-1\"><a href=\"#4、-符号-1\" class=\"headerlink\" title=\"4、() 符号\"></a>4、<code>()</code> 符号</h2><p>通常与<code>|</code>联合使用，用于枚举一系列可替换的字符。<br>例如：电话区号可用“-”或“ ”空格来表示：<br><code>^0[0-9]{2,3}(-| |.*)[0-9]{8}</code></p>\n<h1 id=\"三、通配符\"><a href=\"#三、通配符\" class=\"headerlink\" title=\"三、通配符\"></a>三、通配符</h1><p>通配符和正则表达式之间存在的一些差异，有些相同的字符既用在正则表达式中又用在通配符中，极易造成混淆和干扰，其中的区别要靠多记忆和练习去加深理解，简单的说，正则表达式主要用在对文件内容的匹配上，通配符主要用在对文件名的匹配上。</p>\n<h2 id=\"1、-符号-1\"><a href=\"#1、-符号-1\" class=\"headerlink\" title=\"1、* 符号\"></a>1、<code>*</code> 符号</h2><p>代表0或多个字符<br>例如：<code>ls -l *.doc</code><br>匹配扩展名为doc的任意文件</p>\n<h2 id=\"2、-符号-1\"><a href=\"#2、-符号-1\" class=\"headerlink\" title=\"2、? 符号\"></a>2、<code>?</code> 符号</h2><p>代表任意一个字符<br>例如:<code>ls -l A?.doc</code> 匹配扩展名为doc,名称为A开头,后代一个字符的任意文件</p>\n<h2 id=\"3、-和-符号\"><a href=\"#3、-和-符号\" class=\"headerlink\" title=\"3、{} 和 [] 符号\"></a>3、<code>{}</code> 和 <code>[]</code> 符号</h2><p>匹配所有括号内包含的以逗号隔开的字符<br>例如:<code>ls -l {a,b,c}.doc</code><br>匹配名字是字母a,b,c,扩展名为doc的文件<br>再如:<code>ls -l [a-c].doc</code> 与上例意义相同<br>综合例子：<code>ls -l {a*,b*,c*}.{tmp,txt}</code></p>\n<h2 id=\"4、-符号和-符号\"><a href=\"#4、-符号和-符号\" class=\"headerlink\" title=\"4、^符号和!符号\"></a>4、<code>^</code>符号和<code>!</code>符号</h2><p>这两个符号往往和<code>[]</code>一起使用,当出现在<code>[]</code>中时,代表取反<br>例如:<code>[^A]</code>或<code>[!A]</code>代表不是A</p>\n<h1 id=\"四、grep支持的POSIX字符\"><a href=\"#四、grep支持的POSIX字符\" class=\"headerlink\" title=\"四、grep支持的POSIX字符\"></a>四、grep支持的POSIX字符</h1><ul>\n<li><code>[:alnum:]</code> 文字数字字符</li>\n<li><code>[:alpha:]</code> 文字字符</li>\n<li><code>[:digit:]</code> 数字字符</li>\n<li><code>[:graph:]</code> 非空字符(非空格,控制字符)</li>\n<li><code>[:lower:]</code> 小写字母</li>\n<li><code>[:upper:]</code> 大写字母</li>\n<li><code>[:cntrl:]</code> 控制字符</li>\n<li><code>[:print:]</code> 非空字符(包含空格)</li>\n<li><code>[:punct:]</code> 标点符号</li>\n<li><code>[:space:]</code> 所有空白字符(新行,空格,制表符)</li>\n<li><code>[:xdigit:]</code> 十六进制数字(0-9,a-f)</li>\n</ul>\n<p>例子：<code>grep ^[[:upper:]] greptest.txt</code><br>    The cat’s name is Tom, what’s the mouse’s name?<br>    The mouse’s NAME is Jerry<br>    They are good friends.<br>    Upper case<br><code>grep ^[[:xdigit:]] greptest.txt</code><br>    100% means pure<br>    021-38749087<br>    0556-34538979<br>    010 66508749<br>    01066508749</p>\n","categories":["技术笔记"],"tags":["Linux","正则表达式"]},{"title":"NodeJs模块加载机制","url":"/zh-cn/2017/1/1/NodeJs%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html","content":"<p>Node.js的模块分为两类，一类为原生（核心）模块，一类为文件模块。<br>原生模块在Node.js源代码编译的时候编译进了二进制执行文件，被定义在lib这个目录下面，加载的速度最快。<br>文件模块是动态加载的，加载速度比原生模块慢。但是Node.js对原生模块和文件模块都进行了缓存，于是在第二次require时，是不会有重复开销的。</p>\n<h2 id=\"文件模块加载\"><a href=\"#文件模块加载\" class=\"headerlink\" title=\"文件模块加载\"></a>文件模块加载</h2><p>由于通过命令行加载启动的文件几乎都为文件模块。我们从Node.js如何加载文件模块开始谈起。<br>文件模块的加载，主要由原生模块module来实现和完成，该模块在启动时已经被加载。</p>\n<p>文件模块中，又分为3类模块。这三类文件模块以后缀来区分，Node.js会根据后缀名来决定加载方法。</p>\n<ul>\n<li>.js。通过fs模块同步读取js文件并编译执行。</li>\n<li>.node。通过C/C++进行编写的Addon。通过dlopen方法进行加载。</li>\n<li>.json。读取文件，调用JSON.parse解析加载。</li>\n</ul>\n<p>在此，重点讲js模块加载过程：</p>\n<ul>\n<li><p>模块包装<br>对js文件内容进行头尾包装。以app.js为例，包装之后的app.js将会变成以下形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class=\"line\">    var circle &#x3D; require(&#39;.&#x2F;circle.js&#39;);</span><br><span class=\"line\">    console.log(&#39;The area of a circle of radius 4 is &#39; + circle.area(4));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这段代码执行后，返回为一个具体的function对象。最后传入module对象的exports，require方法，module，文件名，目录名作为实参并执行。这就是为什么require并没有定义在app.js 文件中，但是这个方法却存在的原因。</p>\n</li>\n<li><p>module对象</p>\n<ul>\n<li>module.children：一个数组，指定了当前模块引用的其他模块。</li>\n<li>module.exports ：此对象由Module系统创建，有时不可访问; 如果希望模块成为一个类的实例，只需将所需的导出对象分配给module.exports。</li>\n<li>exports：最初指向module.exports，如果你给它赋值，它将会指向新对象，而不是最初的module.exports。 注意，如果将所需的对象分配给exports，将简单地重新绑定exports变量，这可能不是你想要做的。<br>类似于：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function require(...) &#123;</span><br><span class=\"line\">&#x2F;&#x2F; ...</span><br><span class=\"line\">((module, exports) &#x3D;&gt; &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; Your module code here</span><br><span class=\"line\">  exports &#x3D; some_func;        &#x2F;&#x2F; re-assigns exports, exports is no longer</span><br><span class=\"line\">                              &#x2F;&#x2F; a shortcut, and nothing is exported.</span><br><span class=\"line\">  module.exports &#x3D; some_func; &#x2F;&#x2F; makes your module export 0</span><br><span class=\"line\">&#125;)(module, module.exports);</span><br><span class=\"line\">return module;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>module.filename：模块的绝对路径名称</li>\n<li>module.id ：模块id通常等于module.filename</li>\n<li>module.loaded：用于判断模块是否加载完毕，或者正在加载中。</li>\n<li>module.parent ：指向首次加载本模块的模块。</li>\n<li>module.require(id)：返回一个module.exports导出的对象。</li>\n</ul>\n</li>\n</ul>\n<p>载入、编译、缓存了module后，返回module的exports对象。这就是circle.js文件中只有定义在exports对象上的方法才能被外部调用的原因。</p>\n<ul>\n<li>require方法中的文件查找策略</li>\n</ul>\n<p><img data-src=\"http://www.infoq.com/resource/articles/nodejs-module-mechanism/zh/resources/image1.jpg\" alt=\"enter image description here\"><br>尽管原生模块与文件模块的优先级不同，但是都不会优先于从文件模块的缓存中加载已经存在的模块。以http模块为例，尽管在目录下存在一个http/http.js/http.node/http.json文件，require(“http”)都不会从这些文件中加载，而是从原生模块中加载。</p>\n<p>文件查找流程：<br><img data-src=\"http://www.infoq.com/resource/articles/nodejs-module-mechanism/zh/resources/image2.jpg\" alt=\"enter image description here\"></p>\n<p>简而言之，如果require绝对路径的文件，查找时不会去遍历每一个node_modules目录，其速度最快。其余流程如下：</p>\n<ol>\n<li>从module path数组中取出第一个目录作为查找基准。</li>\n<li>直接从目录中查找该文件，如果存在，则结束查找。如果不存在，则进行下一条查找。</li>\n<li>尝试添加.js、.json、.node后缀后查找，如果存在文件，则结束查找。如果不存在，则进行下一条。</li>\n<li>尝试将require的参数作为一个包来进行查找，读取目录下的package.json文件，取得main参数指定的文件。</li>\n<li>尝试查找该文件，如果存在，则结束查找。如果不存在，则进行第3条查找。</li>\n<li>如果继续失败，则取出module path数组中的下一个目录作为基准查找，循环第1至5个步骤。</li>\n<li>如果继续失败，循环第1至6个步骤，直到module path中的最后一个值。</li>\n<li>如果仍然失败，则抛出异常。</li>\n</ol>\n<p>整个查找过程十分类似原型链的查找和作用域的查找。所幸Node.js对路径查找实现了缓存机制，否则由于每次判断路径都是同步阻塞式进行，会导致严重的性能消耗。</p>\n<h2 id=\"包结构\"><a href=\"#包结构\" class=\"headerlink\" title=\"包结构\"></a>包结构</h2><p>一个符合CommonJS规范的包应该是如下这种结构：</p>\n<ul>\n<li>一个package.json文件应该存在于包顶级目录下</li>\n<li>二进制文件应该包含在bin目录下。</li>\n<li>JavaScript代码应该包含在lib目录下。</li>\n<li>文档应该在doc目录下。</li>\n<li>单元测试应该在test目录下。</li>\n</ul>\n<p>由上文的require的查找过程可以知道，Node.js在没有找到目标文件时，会将当前目录当作一个包来尝试加载，所以在package.json文件中最重要的一个字段就是main。而实际上，这一处是Node.js的扩展，标准定义中并不包含此字段，对于require，只需要main属性即可。详细Package-json包说明参见：<br><a href=\"http://blog.udock.cn/2016/09/09/Nodejs-Package-json-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E/#more\">这篇blog</a></p>\n","categories":["技术参考"],"tags":["Nodejs"]},{"title":"NodeJs-REPL参考","url":"/zh-cn/2017/1/1/NodeJs-REPL%E5%8F%82%E8%80%83.html","content":"<p>REPL表示读取评估和演示打印循环(Read Eval Print Loop)，它代表一个命令输入和系统在交互模式的输出响应窗口控制台或Unix/ Linux的shell计算机环境。 Node.js附带了一个REPL环境。它执行以下期望的任务。<br>Node REPL结合Node.js的代码试验非常有用，用于调试JavaScript代码。</p>\n<ul>\n<li>Read - 读取用户的输入，解析在内存中输入JavaScript数据结构和存储。</li>\n<li>Eval - 接受和评估计算数据结构</li>\n<li>Print - 打印结果</li>\n<li>Loop - 循环上面的命令，直到用户按Ctrl-C两次。</li>\n</ul>\n<h2 id=\"启动REPL\"><a href=\"#启动REPL\" class=\"headerlink\" title=\"启动REPL\"></a>启动REPL</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Usage: node [options] [ -e script | script.js ] [arguments] 2 node debug script.js [arguments]</span><br><span class=\"line\"> Options:</span><br><span class=\"line\">  -v, --version</span><br><span class=\"line\">  -e, --eval script     直接执行javascript代码</span><br><span class=\"line\">  -p, --print           打印 --eval 的结果</span><br><span class=\"line\">  --v8-options          打印V8命令选项</span><br><span class=\"line\">  --max-stack-size&#x3D;val  设置V8栈大小(bytes)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多行表达式\"><a href=\"#多行表达式\" class=\"headerlink\" title=\"多行表达式\"></a>多行表达式</h2><p>Node REPL支持类似于JavaScript的多行表达。让我们来看看以下do-while循环的操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ node</span><br><span class=\"line\">&gt; var x &#x3D; 0</span><br><span class=\"line\">undefined</span><br><span class=\"line\">&gt; do &#123;</span><br><span class=\"line\">... x++;</span><br><span class=\"line\">... console.log(&quot;x: &quot; + x);</span><br><span class=\"line\">... &#125; while ( x &lt; 5 );</span><br><span class=\"line\">x: 1</span><br><span class=\"line\">x: 2</span><br><span class=\"line\">x: 3</span><br><span class=\"line\">x: 4</span><br><span class=\"line\">x: 5</span><br><span class=\"line\">undefined</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"下划线变量\"><a href=\"#下划线变量\" class=\"headerlink\" title=\"下划线变量\"></a>下划线变量</h2><p>您可以使用下划线_得到最后的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ node</span><br><span class=\"line\">&gt; var x &#x3D; 10</span><br><span class=\"line\">undefined</span><br><span class=\"line\">&gt; var y &#x3D; 20</span><br><span class=\"line\">undefined</span><br><span class=\"line\">&gt; x + y</span><br><span class=\"line\">30</span><br><span class=\"line\">&gt; var sum &#x3D; _</span><br><span class=\"line\">undefined</span><br><span class=\"line\">&gt; console.log(sum)</span><br><span class=\"line\">30</span><br><span class=\"line\">undefined</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"REPL命令\"><a href=\"#REPL命令\" class=\"headerlink\" title=\"REPL命令\"></a>REPL命令</h2><ul>\n<li>ctrl + c - 终止当前命令</li>\n<li>ctrl + c twice - 终止Node REPL</li>\n<li>ctrl + d - 终止Node REPL</li>\n<li>Up/Down Keys - 查看命令历史记录和修改以前的命令</li>\n<li>tab Keys - 当前指令的列表</li>\n<li>.help - 所有命令的列表</li>\n<li>.break - 退出多行表达式</li>\n<li>.clear - 退出多行表达式</li>\n<li>.exit - 退出repl</li>\n<li>.save filename - 当前Node REPL会话保存到文件中</li>\n<li>.load filename - 加载文件的内容在当前Node REPL会话</li>\n</ul>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>一门语言在运行的时候，需要一个环境，叫做宿主环境。对于JavaScript，宿主环境最常见的是web浏览器，这时的this通常指代的时window。而在node的REPL中，this指代的是global。</p>\n","categories":["技术参考"],"tags":["Nodejs"]},{"title":"NodeJs实用库参考","url":"/zh-cn/2016/9/9/NodeJs%E5%AE%9E%E7%94%A8%E5%BA%93%E5%8F%82%E8%80%83.html","content":"<p>收录Nodejs使用包，并配以示例介绍用法，日拱一卒，不断积累更新。随着收录的包数量增长，以后再进行提炼和分类。</p>\n<h2 id=\"minimist\"><a href=\"#minimist\" class=\"headerlink\" title=\"minimist\"></a>minimist</h2><p>解析命令行参数和选项</p>\n<ul>\n<li>创建一个新目录</li>\n</ul>\n<p>mkdir test &amp;&amp; cd test</p>\n<ul>\n<li>用npm初始化一个package.json</li>\n</ul>\n<p>npm init //按引导回答一系列提示</p>\n<ul>\n<li>安装minimist包</li>\n</ul>\n<p>npm install minimist –save</p>\n<ul>\n<li>新建minimist文件夹并创建一个新文件parse.js，写入以下代码：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> argv = <span class=\"built_in\">require</span>(<span class=\"string\">'minimist'</span>)(process.argv.slice(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir(argv);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行程序</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">node minimist&#x2F;parse.js -a beep -b boop</span><br><span class=\"line\">&#x2F;&#x2F;结果为：两个选项被解释成了map，使用非常方便</span><br><span class=\"line\">&#123; _: [], a: &#39;beep&#39;, b: &#39;boop&#39; &#125;</span><br></pre></td></tr></table></figure>\n<p>再来一个稍微复杂点的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">node minimist&#x2F;parse.js -x 3 -y 4 -n5 -abc --beep&#x3D;boop foo bar</span><br><span class=\"line\"> baz</span><br><span class=\"line\">&#x2F;&#x2F;结果为：一目了然，使用很方便</span><br><span class=\"line\">&#123; _: [ &#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39; ],</span><br><span class=\"line\">  x: 3,</span><br><span class=\"line\">  y: 4,</span><br><span class=\"line\">  n: 5,</span><br><span class=\"line\">  a: true,</span><br><span class=\"line\">  b: true,</span><br><span class=\"line\">  c: true,</span><br><span class=\"line\">  beep: &#39;boop&#39; &#125;</span><br></pre></td></tr></table></figure>\n<p>选项说明：</p>\n<blockquote>\n<ul>\n<li>opts.string : a string or array of strings argument names to always treat as strings</li>\n<li>opts.boolean : a boolean, string or array of strings to always treat as booleans. if true will treat all double hyphenated arguments without equal signs as boolean (e.g. affects –foo, not -f or –foo=bar)</li>\n<li>opts.alias : an object mapping string names to strings or arrays of string argument names to use as aliases</li>\n<li>opts.default : an object mapping string argument names to default values</li>\n<li>opts.stopEarly : when true, populate argv._ with everything after the first non-option</li>\n<li>opts[‘–’] : when true, populate argv._ with everything before the – and  argv[‘–’] with everything after the –. Here’s an example:</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">require(&#39;&#39;minimist&#39;&#39;)(&#39;one two three -- four five --six&#39;.split(&#39; &#39;), &#123; &#39;--&#39;: true &#125;)</span><br><span class=\"line\">&#123; _: [ &#39;one&#39;, &#39;two&#39;, &#39;three&#39; ],</span><br><span class=\"line\">  &#39;--&#39;: [ &#39;four&#39;, &#39;five&#39;, &#39;--six&#39; ] &#125;</span><br></pre></td></tr></table></figure>\n\n<p>Note that with opts[‘–’] set, parsing for arguments still stops after the –.</p>\n<blockquote>\n<ul>\n<li>opts.unknown - a function which is invoked with a command line parameter not defined in the opts configuration object. If the function returns false, the unknown option is not added to argv.</li>\n</ul>\n</blockquote>\n<h2 id=\"Camel-Case\"><a href=\"#Camel-Case\" class=\"headerlink\" title=\"Camel Case\"></a>Camel Case</h2><p>驼峰命名格式化工具</p>\n<ul>\n<li>安装</li>\n</ul>\n<p>npm install camel-case –save</p>\n<ul>\n<li>使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var camelCase &#x3D; require(&#39;camel-case&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">camelCase(&#39;string&#39;)         &#x2F;&#x2F;&#x3D;&gt; &quot;string&quot;</span><br><span class=\"line\">camelCase(&#39;dot.case&#39;)       &#x2F;&#x2F;&#x3D;&gt; &quot;dotCase&quot;</span><br><span class=\"line\">camelCase(&#39;PascalCase&#39;)     &#x2F;&#x2F;&#x3D;&gt; &quot;pascalCase&quot;</span><br><span class=\"line\">camelCase(&#39;version 1.2.10&#39;) &#x2F;&#x2F;&#x3D;&gt; &quot;version_1_2_10&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">camelCase(&#39;STRING 1.2&#39;, &#39;tr&#39;) &#x2F;&#x2F;&#x3D;&gt; &quot;strıng_1_2&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">camelCase(&#39;string 1 2 3&#39;, null, true) &#x2F;&#x2F;&#x3D;&gt; &quot;string123&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"No-Case\"><a href=\"#No-Case\" class=\"headerlink\" title=\"No Case\"></a>No Case</h2><p>转换字符串为小写并以空格分割格式化工具</p>\n<ul>\n<li>安装</li>\n</ul>\n<p>npm install no-case –save</p>\n<ul>\n<li>使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var noCase &#x3D; require(&#39;no-case&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">noCase(null)              &#x2F;&#x2F;&#x3D;&gt; &quot;&quot;</span><br><span class=\"line\">noCase(&#39;string&#39;)          &#x2F;&#x2F;&#x3D;&gt; &quot;string&quot;</span><br><span class=\"line\">noCase(&#39;dot.case&#39;)        &#x2F;&#x2F;&#x3D;&gt; &quot;dot case&quot;</span><br><span class=\"line\">noCase(&#39;camelCase&#39;)       &#x2F;&#x2F;&#x3D;&gt; &quot;camel case&quot;</span><br><span class=\"line\">noCase(&#39;Beyoncé Knowles&#39;) &#x2F;&#x2F;&#x3D;&gt; &quot;beyoncé knowles&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">noCase(&#39;A STRING&#39;, &#39;tr&#39;) &#x2F;&#x2F;&#x3D;&gt; &quot;a strıng&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">noCase(&#39;HELLO WORLD!&#39;, null, &#39;_&#39;) &#x2F;&#x2F;&#x3D;&gt; &quot;hello_world&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"node-readme\"><a href=\"#node-readme\" class=\"headerlink\" title=\"node-readme\"></a>node-readme</h2><p>采用一个ES6的模板，自动生成README.md文件</p>\n<ul>\n<li>安装</li>\n</ul>\n<p>npm install –save-dev node-readme</p>\n<ul>\n<li>使用<br>在package.json文件中为你的模块增加一个命令：然后可以用 npm run readme 命令来生成README.md文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;readme&quot;: &quot;node .&#x2F;node_modules&#x2F;.bin&#x2F;node-readme&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Jldm9sdW5ldC9ub2RlLXJlYWRtZS9ibG9iL21hc3Rlci9zcmMvLlJFQURNRS5tZA==\">详细模板<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>通配符匹配：Glob： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2I=\">https://github.com/isaacs/node-glob<i class=\"fa fa-external-link-alt\"></i></span><br>时间处理工具：Moments：<span class=\"exturl\" data-url=\"aHR0cDovL21vbWVudGpzLmNvbS8=\">http://momentjs.com/<i class=\"fa fa-external-link-alt\"></i></span><br>项目生成器脚手架： <span class=\"exturl\" data-url=\"aHR0cDovL3llb21hbi5pby8=\">http://yeoman.io/<i class=\"fa fa-external-link-alt\"></i></span></p>\n","categories":["技术参考"],"tags":["Nodejs"]},{"title":"Nodejs Package.json 简要说明","url":"/zh-cn/2016/9/9/Nodejs-Package-json-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E.html","content":"<p>Nodejs包定义文件，配置参数详细解读。</p>\n<p><em>TODO：以后会区分出不同的Node版本支持的配置参数</em></p>\n<p>Package.json文件描述了一个NPM包的所有相关信息，包括作者、简介、包依赖、构建等信息。格式必须是严格的JSON格式。</p>\n<p>通常我们在创建一个NPM程序时，可以使用<code>npm init</code>命令，通过交互式的命令，自动生成一个package.json文件，里面包含了常用的一些字段信息，但远不止这么简单。通过完善package.json文件，我们可以让npm命令更好地为我们服务。下面简要介绍包定义文件中各部分的作用和含义：</p>\n<ul>\n<li>name &amp; version</li>\n</ul>\n<p>name和version是package.json中最重要的两个字段，也是发布到NPM平台上的唯一标识，如果没有正确设置这两个字段，包就不能发布和被下载。<br><strong>name字段：</strong>新版本的NPM可以指定scope, 名字可以加前缀标识，如<code>@ijse/mypackage</code><br><strong>version字段：</strong>取值需要符合node-semver的规则，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLXNlbXZlcg==\">详见文档<i class=\"fa fa-external-link-alt\"></i></span><br>下面是官方给出的一些建议:</p>\n<blockquote>\n<ul>\n<li>名字里不要再包含”js”和”node”，因为默认NPM包就是node.js程序，不过你可以通过engines字段来指定。</li>\n<li>名字将会被作为url的一部分，所有要符合http url的一般命名规则，不能包含url非法字符，也不能以.和_开头。</li>\n<li>名字也将作为require()命令的参数，所以应该尽量简明。</li>\n<li>如果包要发布到NPM平台上的话，最好先检查下有没有重名, 并且字母只能全部小写。</li>\n</ul>\n</blockquote>\n<ul>\n<li>description<br>包的描述信息，将会在<code>npm search</code>的返回结果中显示，以帮助用户选择合适的包。</li>\n<li>keywords<br>包的关键词信息，是一个字符串数组，同上也将显示在<code>npm search</code>的结果中。</li>\n<li>homepage：包的主页地址</li>\n<li>license：包的开源协议名称</li>\n<li>author：包的作者，可以是字符串或对象，如：</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">  author: &#123;  </span><br><span class=\"line\">    \"name\": \"ijse\",</span><br><span class=\"line\">    \"email\": \"my@ijse.cn\",</span><br><span class=\"line\">    \"url\": \"http://www.ijser.cn\"</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\">  author: \"ijse &lt;my@ijser.cn&gt; (http://www.ijser.cn)\"</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>bugs：包的bug跟踪主页地址，应该如下设置：</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">bugs: &#123;  </span><br><span class=\"line\">  \"url\": \"http://github.com/ijse/project/issues\",</span><br><span class=\"line\">  \"email\": \"my@ijser.cn\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>contributors &amp; maintainers：包的贡献者和维护人，是一个数组。</li>\n<li>files：包所包含的所有文件，可以取值为文件夹。通常我们还是用<code>.npmignore</code>来去除不想包含到包里的文件。</li>\n<li>main：包的入口文件，如index.js</li>\n<li>bin：如果你的包里包含可执行文件，通过设置这个字段可以将它们包含到系统的PATH中，这样直接就可以运行，很方便。当包被安装后，NPM将创建一个cli.js文件的链接到/usr/local/bin/iapp下。如：</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"bin\": &#123;</span><br><span class=\"line\">  \"iapp\": \"./cli.js\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>man：为系统的man命令提供帮助文档, 帮助文件的文件名必须以数字结尾，如果是压缩的，需要以.gz结尾。如：</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"man\": \"./man/doc.1\"</span><br><span class=\"line\"><span class=\"comment\">//如果是字符串数组，则分别可以man foo, man foo-bar, man 2 foo来查看。：</span></span><br><span class=\"line\">\"name\": \"foo\",</span><br><span class=\"line\">\"man\": [\"./man/foo.1\", \"./man/bar.1\", \"./man/foo.2\" ]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>directories：CommonJS包所要求的目录结构信息，目前除了告诉别人你的程序目录结构，貌似没有别的什么用。 下级字段可以是：<code>lib, bin, man, doc, example</code>。 每个都是字符串。</li>\n<li>repository：包的仓库地址。如：</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"repository\": &#123;</span><br><span class=\"line\">  \"type\": \"git\",</span><br><span class=\"line\">  \"url\": \"http://github.com/ijse/project.git\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>scripts &amp; config：通过设置这个可以使NPM调用一些命令脚本，封装一些功能。config可以添加一些设置，供scripts读取用，同时这里的值也会被添加到系统的环境变量中。</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//npm start的时候会读取到npm_package_config_port环境变量。</span></span><br><span class=\"line\">\"name\": \"foo\",</span><br><span class=\"line\">\"config\": &#123;</span><br><span class=\"line\">  \"port\": \"8080\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//同时也可以使用npm config命令来修改设置：</span></span><br><span class=\"line\">npm config set foo:port 8001</span><br></pre></td></tr></table></figure>\n<ul>\n<li>dependencies：指定依赖的其它包，这些依赖是指包发布后正常执行时所需要的，通常使用下面命令来安装：</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save otherpackage</span><br></pre></td></tr></table></figure>\n<p>引用包的版本形式可以有如下多种：</p>\n<blockquote>\n<ul>\n<li>version 严格匹配某个版本</li>\n<li><code>&gt;version</code> 必须大于某个版本</li>\n<li><code>&gt;=version</code></li>\n<li><code>&lt;version</code></li>\n<li><code>&lt;=version</code></li>\n<li><code>~version</code> 大概匹配某个版本</li>\n<li><code>^version</code> 兼容某个版本</li>\n<li>1.2.x 可以是1.2.0, 1.2.1等等，但不能是1.3.0</li>\n<li>http://… 指定tarball的url地址</li>\n<li><code>*</code> 任何版本都可以</li>\n<li><code>&quot;&quot;</code> 同上</li>\n<li><code>version1 - version2</code>：说明 <code>&gt;=version1 &lt;=version2</code></li>\n<li><code>range1 || range2</code>: 满足range1 或range2</li>\n<li><code>git://...</code> git地址</li>\n<li><code>user/repo</code> 同上</li>\n<li><code>tag</code> 指定某个tag的版本</li>\n<li><code>path/path</code> 本地包所有文件夹</li>\n</ul>\n</blockquote>\n<p>例如，以下都是可用的：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"dependencies\"</span> :</span><br><span class=\"line\">  &#123; <span class=\"attr\">\"foo\"</span> : <span class=\"string\">\"1.0.0 - 2.9999.9999\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"bar\"</span> : <span class=\"string\">\"&gt;=1.0.2 &lt;2.1.2\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"baz\"</span> : <span class=\"string\">\"&gt;1.0.2 &lt;=2.3.4\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"boo\"</span> : <span class=\"string\">\"2.0.1\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"qux\"</span> : <span class=\"string\">\"&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"asd\"</span> : <span class=\"string\">\"http://asdf.com/asdf.tar.gz\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"til\"</span> : <span class=\"string\">\"~1.2\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"elf\"</span> : <span class=\"string\">\"~1.2.3\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"two\"</span> : <span class=\"string\">\"2.x\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"thr\"</span> : <span class=\"string\">\"3.3.x\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"lat\"</span> : <span class=\"string\">\"latest\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"dyl\"</span> : <span class=\"string\">\"file:../dyl\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Git URL可以有如下种形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git:&#x2F;&#x2F;github.com&#x2F;user&#x2F;project.git#commit-ish  </span><br><span class=\"line\">git+ssh:&#x2F;&#x2F;user@hostname:project.git#commit-ish  </span><br><span class=\"line\">git+ssh:&#x2F;&#x2F;user@hostname&#x2F;project.git#commit-ish  </span><br><span class=\"line\">git+http:&#x2F;&#x2F;user@hostname&#x2F;project&#x2F;blah.git#commit-ish  </span><br><span class=\"line\">git+https:&#x2F;&#x2F;user@hostname&#x2F;project&#x2F;blah.git#commit-ish</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>devDependencies：如果是开发中依赖的包，可以在devDependencies设置。语法同上。还可以通过命令行来添加：</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev mypack</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>peerDependencies：相关的依赖，如果你的包是插件，而用户在使用你的包时候，通常也会需要这些依赖（插件），那么可以将依赖列到这里。举个例子，如karma, 这些都是karma的相关插件，一般使用karma的时候都会需要。它的package.json中有设置：</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"peerDependencies\": &#123;</span><br><span class=\"line\">  \"karma-jasmine\": \"~0.1.0\",</span><br><span class=\"line\">  \"karma-requirejs\": \"~0.2.0\",</span><br><span class=\"line\">  \"karma-coffee-preprocessor\": \"~0.1.0\",</span><br><span class=\"line\">  \"karma-html2js-preprocessor\": \"~0.1.0\",</span><br><span class=\"line\">  \"karma-chrome-launcher\": \"~0.1.0\",</span><br><span class=\"line\">  \"karma-firefox-launcher\": \"~0.1.0\",</span><br><span class=\"line\">  \"karma-phantomjs-launcher\": \"~0.1.0\",</span><br><span class=\"line\">  \"karma-script-launcher\": \"~0.1.0\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>bundledDependencies：绑定的依赖包，发布的时候这些绑定包也会被一同发布。</li>\n<li>optionalDependencies：即使这些依赖没有，也可以正常安装使用。</li>\n<li>engines：指定包运行的环境，如：//engineStrict设置为true强制限定 engine</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"engines\": &#123;</span><br><span class=\"line\">  \"node\": \"&gt;=0.10.3 &lt; 0.12\",</span><br><span class=\"line\">  \"npm\": \"~1.0.20\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>os：指定你的包可以在哪些系统平台下运行。如下例，该包即可以在darwin和linux平台下运行，而不能在win32下(取值来自<code>process.platform</code>)。还可以指定包运行的cpu架构（取值来自<code>process.arch</code>），如：</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"os\": [ \"darwin\", \"linux\", \"!win32\" ]</span><br><span class=\"line\">\"cpu\": [ \"x64\", \"!arm\" ]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>preferGlobal：如果你的包是命令行运行的，那可以将其设置为true建议用户全局(npm install -g)安装。但它并不强制用户。</li>\n<li>private：设为true这个包将不会发布到NPM平台下。</li>\n<li>publishConfig：这个字段用于设置发布时候的一些设定。尤其方便你希望发布前设定指定的tag或registry。也可以设定其它子字段，但只有tag和registry会影响到发布。</li>\n</ul>\n<p><strong>NPM的一些默认值说明</strong></p>\n<ul>\n<li><code>&quot;scripts&quot;: { &quot;start&quot;: &quot;node server.js&quot; }</code><br>//如果在项目根目录下含有server.js文件，则NPM会自动设置此值。</li>\n<li><code>&quot;scripts&quot;: { &quot;preinstall&quot;: &quot;node-gyp rebuild&quot; }</code><br>//如果在项目根目录下含有binding.gyp文件，则NPM会自动设置此值。</li>\n<li><code>&quot;contributors&quot;: [...]</code><br>//如果项目根目录下含有AUTHORS文件，则NPM会自动将每一行以Name <email> (url)的格式读取并设定此字段。</li>\n</ul>\n","categories":["技术笔记"],"tags":["Nodejs"]},{"title":"RabbitMQ学习","url":"/zh-cn/2017/1/1/RabbitMQ%E5%AD%A6%E4%B9%A0.html","content":"<p>仅供学习记录备查使用。<br><span class=\"exturl\" data-url=\"aHR0cDovL3JhYmJpdG1xLm1yLXBpbmcuY29tLw==\">原始网站<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"名词\"><a href=\"#名词\" class=\"headerlink\" title=\"名词\"></a>名词</h2><ul>\n<li>生产(Producing)意思就是发送。发送消息的程序就是一个生产者(producer)。我们一般用 “P” 来表示</li>\n<li>队列(queue)就是邮箱的名称。消息通过你的应用程序和 RabbitMQ 进行传输，它们能够只存储在一个队列（queue）中。 队列（queue）没有任何限制，你要存储多少消息都可以——基本上是一个无限的缓冲。多个生产者（producers）能够把消息发送给同一个队列，同样，多个消费者（consumers）也能够从同一个队列（queue）中获取数据。队列可以绘制成这样（图上是队列的名称）</li>\n<li>消费（Consuming）和获取消息是一样的意思。一个消费者（consumer）就是一个等待获取消息的程序。我们把它绘制为 “C”</li>\n<li>工作队列（又称：任务队列——Task Queues）是为了避免等待一些占用大量资源、时间的操作。当我们把任务（Task）当作消息发送到队列中，一个运行在后台的工作者（worker）进程就会取出任务然后处理。当你运行多个工作者（workers），任务就会在它们之间共享。</li>\n</ul>\n<h2 id=\"机制\"><a href=\"#机制\" class=\"headerlink\" title=\"机制\"></a>机制</h2><p>RabbitMQ 使用的是 AMQP 协议</p>\n<p>RabbitMQ消息模型的核心理念是：发布者（producer）不会直接发送任何消息给队列。事实上，发布者（producer）甚至不知道消息是否已经被投递到队列。</p>\n<p>发布者（producer）只需要把消息发送给一个交换机（exchange）。交换机非常简单，它一边从发布者方接收消息，一边把消息推送到队列。交换机必须知道如何处理它接收到的消息，是应该推送到指定的队列还是是多个队列，或者是直接忽略消息。这些规则是通过交换机类型（exchange type）来定义的。</p>\n<p><img data-src=\"http://www.rabbitmq.com/img/tutorials/exchanges.png\" alt=\"image\"></p>\n<p>有几个可供选择的交换机类型：直连交换机（direct）, 主题交换机（topic）, （头交换机）headers和 扇型交换机（fanout）。</p>\n<p>扇型交换机（fanout exchange）没有足够的灵活性 —— 它能做的仅仅是广播。</p>\n<p>直连交换机（direct exchange），可以通过路由选择具体的消费者，但没办法基于多个标准执行路由操作</p>\n<p>主题交换机（topic exchange）一个携带着特定路由键的消息会被主题交换机投递给绑定键与之想匹配的队列</p>\n<blockquote>\n<p> 路由键必须是一个由.分隔开的词语列表。这些单词随便是什么都可以，但是最好是跟携带它们的消息有关系的词汇。以下是几个推荐的例子：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”。词语的个数可以随意，但是不要超过255字节。绑定键也必须拥有同样的格式。</p>\n</blockquote>\n<p>绑定键和路由键有两个特殊应用方式：</p>\n<ul>\n<li><code>*</code> (星号) 用来表示一个单词.</li>\n<li><code>#</code> (井号) 用来表示任意数量（零个或多个）单词。</li>\n</ul>\n<p><img data-src=\"http://www.rabbitmq.com/img/tutorials/python-five.png\" alt=\"image\"></p>\n<p>主题交换机是很强大的，它可以表现出跟其他交换机类似的行为</p>\n<ul>\n<li>当一个队列的绑定键为 “#”（井号） 的时候，这个队列将会无视消息的路由键，接收所有的消息。</li>\n<li>当 * (星号) 和 # (井号) 这两个特殊字符都未在绑定键中出现的时候，此时主题交换机就拥有的直连交换机的行为。</li>\n</ul>\n<p>todo：头交换机</p>\n<p>绑定（binding）是指交换机（exchange）和队列（queue）的关系。可以简单理解为：这个队列（queue）对这个交换机（exchange）的消息感兴趣。</p>\n<p>绑定的时候可以带上一个额外的routing_key参数。我们把它叫做绑定键（binding key）绑定键的意义取决于交换机（exchange）的类型。我们之前使用过的扇型交换机（fanout exchanges）会忽略这个值。</p>\n<p>如果没有绑定队列到交换器，消息将会丢失。但这个没有所谓，如果没有消费者监听，那么消息就会被忽略。</p>\n<h3 id=\"消息确认\"><a href=\"#消息确认\" class=\"headerlink\" title=\"消息确认\"></a>消息确认</h3><p>为了防止消息丢失，RabbitMQ提供了消息响应（acknowledgments）。消费者会通过一个ack（响应），告诉RabbitMQ已经收到并处理了某条消息，然后RabbitMQ就会释放并删除这条消息。</p>\n<h3 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h3><p>将消息设为持久化并不能完全保证不会丢失。以上代码只是告诉了RabbitMq要把消息存到硬盘，但从RabbitMq收到消息到保存之间还是有一个很小的间隔时间。因为RabbitMq并不是所有的消息都使用fsync(2)——它有可能只是保存到缓存中，并不一定会写到硬盘中。并不能保证真正的持久化，但已经足够应付我们的简单工作队列。如果你一定要保证持久化，你需要改写你的代码来支持事务（transaction）</p>\n<p>如果你没有特意告诉RabbitMQ，那么在它退出或者崩溃的时候，将会丢失所有队列和消息。为了确保信息不会丢失，有两个事情是需要注意的：我们必须把“队列”和“消息”设为持久化。<br>首先，为了不让队列消失，需要把队列声明为持久化（durable）</p>\n","categories":["技术笔记"],"tags":["RabbitMQ"]},{"title":"Hexo源码分析","url":"/zh-cn/2016/9/9/hexo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html","content":"<h2 id=\"从hexo-cli开始\"><a href=\"#从hexo-cli开始\" class=\"headerlink\" title=\"从hexo-cli开始\"></a>从hexo-cli开始</h2><p>（hexo-cli的安装请自行查阅网站）<br>hexo命令从usr/local/bin目录加载，调用../lib<br>/node_modules/hexo-cli/bin/hexo,再调用../lib/hexo.js</p>\n<h2 id=\"主程序模块\"><a href=\"#主程序模块\" class=\"headerlink\" title=\"主程序模块\"></a>主程序模块</h2><p>入口entry:<br>1.获取命令cmd和参数args，并对args用minimist进行处理。<br>2.加载了context.js（见”context模块”节）<br>3.加载了logger，在context中定义<br>4.定义了错误处理方法<br>5.findPkg从当前目录或者–cwd指定的工作目录，一直向上级目录查找package.json,直到找到含有此文件，并且是合法的hexo站点的目录路径后返回，如果没找到hexo模块则执行第8步<br>6.设置hexo的根目录为base_dir<br>7.加载hexo模块(如果hexo不是全局安装的，将无法加载，因此需要在hexo站点目录执行，或者使用–cwd参数指定站点目录)，若主模块加载成功，将new一个Hexo对象并返回（见“hexo主模块”节）<br>8.执行console模块（lib/console/index.js），如果获取到hexo模块则传入，否则只是传入当前的上下文（context模块），将help,init,version模块注册到extend.console<br>9.执行hexo.init(),如果没有找到hexo主模块，则context中init是一个空方法，估计是只为了触发init事件，便于插件在此时挂载，否则执行hexo主模块中的init方法。</p>\n<h2 id=\"context模块\"><a href=\"#context模块\" class=\"headerlink\" title=\"context模块\"></a>context模块</h2><p>入口构造函数：<br>1.传入命令路径cmd和参数args<br>2.将自身注册为事件发射器（EventEmitter）<br>3.初始化logger<br>4.加载了Console Extend模块（extend/console.js），放在extend属性中。（见”extend/console模块”节）<br>5.定义call方法，通过名字获取extend中的插件，并调用。</p>\n<h2 id=\"extend-console模块\"><a href=\"#extend-console模块\" class=\"headerlink\" title=\"extend/console模块\"></a>extend/console模块</h2><p>console模块有两个属性：</p>\n<ul>\n<li>store 存放插件function对象</li>\n<li>alias 存放以插件名称缩写的</li>\n</ul>\n<p>定义register方法，用来注册插件，插件都包装成Promise</p>\n<h2 id=\"hexo主模块\"><a href=\"#hexo主模块\" class=\"headerlink\" title=\"hexo主模块\"></a>hexo主模块</h2><p>构造函数：<br>1.获取路径和参数，注意所有的文件目录路径加载都是基于你执行目录或用–cwd制定的目录，正常应该是你网站生成器的主目录。<br>2.将自己注册为事件发射器<br>3.定义资源目录：public、source、node_modules、scripts、scaffolds、themes以及themes下面的scripts目录<br>4.将各类调试以及生成参数（包括启动hexo时的参数），定义到env属性中<br>5.加载配置文件，默认是基目录下的_config.yml，也可以从–config参数自行制定<br>6.加载扩展</p>\n<ul>\n<li>console： 命令注册中心，见“extend/console模块“节</li>\n<li>deployer: 部署插件注册中心</li>\n<li>filter：过滤器注册中心，有两种filter：before_post_render,after_post_render，同时定义了解除注册、执行和同步执行方法</li>\n<li>generator：生成器注册中心</li>\n<li>helper：帮助插件注册中心</li>\n<li>migrator：迁移插件注册中心</li>\n<li>processor：处理器注册中心</li>\n<li>renderer：视图渲染器注册中心</li>\n<li>tag<br>7.设置config、log、render、route、post、scaffold、database</li>\n</ul>\n","categories":["技术笔记"],"tags":["Hexo"]},{"title":"Vim快捷键速查表","url":"/zh-cn/2016/9/9/vim%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%80%9F%E6%9F%A5%E8%A1%A8.html","content":"<p>vim速查表。</p>\n<h2 id=\"编辑模式\"><a href=\"#编辑模式\" class=\"headerlink\" title=\"编辑模式\"></a>编辑模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi&#x3D;&gt;operation: vi</span><br><span class=\"line\">normal&#x3D;&gt;operation: 一般模式（正常）</span><br><span class=\"line\">edit&#x3D;&gt;operation: 编辑模式</span><br><span class=\"line\">command&#x3D;&gt;operation: 命令模式</span><br><span class=\"line\"></span><br><span class=\"line\">vi-&gt;normal-&gt;edit-&gt;command</span><br></pre></td></tr></table></figure>\n<p>todo: 学习flow高级语法</p>\n<h2 id=\"光标移动快捷键\"><a href=\"#光标移动快捷键\" class=\"headerlink\" title=\"光标移动快捷键\"></a>光标移动快捷键</h2><table>\n<thead>\n<tr>\n<th align=\"left\">键</th>\n<th align=\"left\">动作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">h</td>\n<td align=\"left\">光标左移</td>\n</tr>\n<tr>\n<td align=\"left\">j</td>\n<td align=\"left\">光标下移</td>\n</tr>\n<tr>\n<td align=\"left\">k</td>\n<td align=\"left\">光标上移</td>\n</tr>\n<tr>\n<td align=\"left\">l</td>\n<td align=\"left\">光标右移</td>\n</tr>\n<tr>\n<td align=\"left\">$</td>\n<td align=\"left\">移动到本行末尾</td>\n</tr>\n<tr>\n<td align=\"left\">:n</td>\n<td align=\"left\">移动到第n行</td>\n</tr>\n<tr>\n<td align=\"left\">n(数字，回车)</td>\n<td align=\"left\">向下移动n行</td>\n</tr>\n<tr>\n<td align=\"left\">Ctrl+f</td>\n<td align=\"left\">后翻页</td>\n</tr>\n<tr>\n<td align=\"left\">Ctrl+b</td>\n<td align=\"left\">前翻页</td>\n</tr>\n<tr>\n<td align=\"left\">Ctrl+d</td>\n<td align=\"left\">后翻半页</td>\n</tr>\n<tr>\n<td align=\"left\">Ctrl+u</td>\n<td align=\"left\">前翻半页</td>\n</tr>\n</tbody></table>\n<h2 id=\"编辑操作快捷键\"><a href=\"#编辑操作快捷键\" class=\"headerlink\" title=\"编辑操作快捷键\"></a>编辑操作快捷键</h2><table>\n<thead>\n<tr>\n<th align=\"left\">键</th>\n<th align=\"left\">动作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ndd（n是数字）</td>\n<td align=\"left\">删除光标所在行内的n行文字</td>\n</tr>\n<tr>\n<td align=\"left\">dw/de(or ndw,dnw）</td>\n<td align=\"left\">删除光标往后一个单词</td>\n</tr>\n<tr>\n<td align=\"left\">d$</td>\n<td align=\"left\">自光标处删除到行尾</td>\n</tr>\n<tr>\n<td align=\"left\">cw/ce(or ncw,cnw）</td>\n<td align=\"left\">改变光标往后一个单词</td>\n</tr>\n<tr>\n<td align=\"left\">c$</td>\n<td align=\"left\">自光标处改变到行尾</td>\n</tr>\n<tr>\n<td align=\"left\">x</td>\n<td align=\"left\">光标处向后删除一个字符</td>\n</tr>\n<tr>\n<td align=\"left\">X</td>\n<td align=\"left\">光标处向前删除一个字符</td>\n</tr>\n<tr>\n<td align=\"left\">yy</td>\n<td align=\"left\">复制光标所在行</td>\n</tr>\n<tr>\n<td align=\"left\">nyy（n是数字）</td>\n<td align=\"left\">复制光标所在行在内的n行</td>\n</tr>\n<tr>\n<td align=\"left\">p</td>\n<td align=\"left\">将复制的文本黏贴在光标的下一行</td>\n</tr>\n<tr>\n<td align=\"left\">u</td>\n<td align=\"left\">撤销操作</td>\n</tr>\n<tr>\n<td align=\"left\">Ctrl+r</td>\n<td align=\"left\">重做操作</td>\n</tr>\n<tr>\n<td align=\"left\">i</td>\n<td align=\"left\">在光标处进行插入操作</td>\n</tr>\n<tr>\n<td align=\"left\">I</td>\n<td align=\"left\">在光标所在行第一个非空处进行添加</td>\n</tr>\n<tr>\n<td align=\"left\">o</td>\n<td align=\"left\">在光标处下一行插入新行进行编辑</td>\n</tr>\n<tr>\n<td align=\"left\">O</td>\n<td align=\"left\">在光标处上一行插入新行进行编辑</td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td align=\"left\">在光标后一个字符处进行插入操作</td>\n</tr>\n<tr>\n<td align=\"left\">A</td>\n<td align=\"left\">在光标所在行最后一个字符处进行插入操作</td>\n</tr>\n<tr>\n<td align=\"left\">R</td>\n<td align=\"left\">进入替换模式</td>\n</tr>\n</tbody></table>\n<h2 id=\"关键字替换\"><a href=\"#关键字替换\" class=\"headerlink\" title=\"关键字替换\"></a>关键字替换</h2><table>\n<thead>\n<tr>\n<th align=\"left\">键</th>\n<th align=\"left\">动作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>n1,n2s/key/newWord/g</code></td>\n<td align=\"left\">将n1-n2行之间所有的key，替换成newWord</td>\n</tr>\n<tr>\n<td align=\"left\"><code>1,$s/key/newWord/g</code></td>\n<td align=\"left\">将第一行到最后一行之间所有的key，替换成newWord</td>\n</tr>\n<tr>\n<td align=\"left\"><code>%s/key/newWord/g</code></td>\n<td align=\"left\">将第一行到最后一行之间所有的key，替换成newWord</td>\n</tr>\n<tr>\n<td align=\"left\"><code>s/key/newWord/g</code></td>\n<td align=\"left\">将本行所有的key，替换成newWord</td>\n</tr>\n<tr>\n<td align=\"left\"><code>s/key/newWord</code></td>\n<td align=\"left\">将本行第一次出现的key，替换成newWord</td>\n</tr>\n</tbody></table>\n<h2 id=\"vim快捷键\"><a href=\"#vim快捷键\" class=\"headerlink\" title=\"vim快捷键\"></a>vim快捷键</h2><table>\n<thead>\n<tr>\n<th align=\"left\">键</th>\n<th align=\"left\">动作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Ctrl+v</td>\n<td align=\"left\">列选择模式</td>\n</tr>\n<tr>\n<td align=\"left\">Shft+v</td>\n<td align=\"left\">行选择模式</td>\n</tr>\n<tr>\n<td align=\"left\">y</td>\n<td align=\"left\">复制</td>\n</tr>\n<tr>\n<td align=\"left\">d</td>\n<td align=\"left\">删除 + 复制（注意很临时）</td>\n</tr>\n<tr>\n<td align=\"left\">p</td>\n<td align=\"left\">粘贴</td>\n</tr>\n<tr>\n<td align=\"left\">:n</td>\n<td align=\"left\">下一个文件</td>\n</tr>\n<tr>\n<td align=\"left\">:N</td>\n<td align=\"left\">上一个文件</td>\n</tr>\n<tr>\n<td align=\"left\">:files</td>\n<td align=\"left\">查看一共打开了几个文件</td>\n</tr>\n<tr>\n<td align=\"left\">Ctrl+g</td>\n<td align=\"left\">显示当前编辑文件的状态及光标行号</td>\n</tr>\n<tr>\n<td align=\"left\">G +n +G</td>\n<td align=\"left\">跳转行号</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:！</code></td>\n<td align=\"left\">执行外部命令</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:r filename or cmd name</code></td>\n<td align=\"left\">当前文件中插入另外内容</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:w filename</code></td>\n<td align=\"left\">当前文件内容写入外部文件</td>\n</tr>\n</tbody></table>\n<p>todo：用vimtutor持续练习</p>\n","categories":["技术笔记"],"tags":["Linux","编码工具"]},{"title":"实用网址","url":"/zh-cn/2017/1/1/%E5%AE%9E%E7%94%A8%E7%BD%91%E5%9D%80.html","content":"<p>收录一些实用的网址备查，记录常用命令。</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><p>MongoDB：<br>启动mongodb： mongod –config /usr/local/etc/mongod.conf</p>\n<h2 id=\"电子书\"><a href=\"#电子书\" class=\"headerlink\" title=\"电子书\"></a>电子书</h2><p>RxJs中文书：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20vYm9vay9idWN0d2J6cy9yeGpzL2RldGFpbHM=\">https://www.gitbook.com/book/buctwbzs/rxjs/details<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"实用网址\"><a href=\"#实用网址\" class=\"headerlink\" title=\"实用网址\"></a>实用网址</h2><p>图标：<br><span class=\"exturl\" data-url=\"aHR0cDovL2ZvbnRhd2Vzb21lLmlvLw==\">http://fontawesome.io/<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>维基百科-端口列表：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvVENQL1VEUCVFNyVBQiVBRiVFNSU4RiVBMyVFNSU4OCU5NyVFOCVBMSVBOCMxMDI0LkU1Ljg4LkIwNDkxNTEuRTguOTkuOUYuRTcuQUIuQUYuRTUuOEYuQTM=\">https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8#1024.E5.88.B049151.E8.99.9F.E7.AB.AF.E5.8F.A3<i class=\"fa fa-external-link-alt\"></i></span></p>\n","categories":["记录"],"tags":["实用工具"]},{"title":"微信应用号开发尝鲜--开发环境搭建","url":"/zh-cn/2016/9/9/%E5%BE%AE%E4%BF%A1%E5%BA%94%E7%94%A8%E5%8F%B7%E5%BC%80%E5%8F%91%E5%B0%9D%E9%B2%9C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html","content":"<p>微信应用号（WX-app）终于来了！由于目前还处于内测阶段，微信只邀请了部分企业参与封测。大多数人还只能等待，但是，为了满足广大技术客学习的热切期望，有大牛已经发布了crack程序，使得我们可以在第一时间进行尝鲜，学习。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NhbXB4L3dlYXBwLWlkZS1jcmFjaw==\">原文链接：对crack方法感兴趣的点这<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>我对原文做了整理，请点击【阅读全文】了解环境搭建过程。希望学习WX-app、Nodejs开发的朋友，可加QQ群学习交流（260272883）</p>\n<p><img data-src=\"http://ooo.0o0.ooo/2016/09/23/57e4e32f50a7f.png\" alt=\"微信应用号开发极客群群二维码\"></p>\n<h2 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h2><p>以下步骤所需要的资料请点击 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMWdlU3lUNno=\">百度云盘<i class=\"fa fa-external-link-alt\"></i></span>下载 内含微信开发工具0.7和0.9版、crack包以及demo。</p>\n<h2 id=\"破解步骤（亲测可用）\"><a href=\"#破解步骤（亲测可用）\" class=\"headerlink\" title=\"破解步骤（亲测可用）\"></a>破解步骤（亲测可用）</h2><ol>\n<li><p>安装0.9版的开发工具</p>\n</li>\n<li><p>打开『微信Web开发者工具』的程序目录</p>\n<ul>\n<li>Windows：用crack包里的文件替换以下目录中的同名文件：</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\package.nw\\app\\dist\\components\\create\\createstep.js</span><br><span class=\"line\">\\package.nw\\app\\dist\\stroes\\projectStores.js</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Mac：右键点击0.9版开发工具的图标，选择『显示包内容』，（完整目录:/Applications/wechatwebdevtools.app/Contents）,用crack包里的文件替换以下目录中的同名文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;Resources&#x2F;app.nw&#x2F;app&#x2F;dist&#x2F;components&#x2F;create&#x2F;createstep.js</span><br><span class=\"line\">&#x2F;Resources&#x2F;app.nw&#x2F;app&#x2F;dist&#x2F;stroes&#x2F;projectStores.js</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>替换后破解完成</li>\n</ol>\n<p>如果破解完成后无法登陆，提示：<code>please bind your wechat account to the appid first</code><br>解决办法：先安装0.7版的开发者工具，进行扫码登陆，登陆成功后，再用0.9版打开就可以了.</p>\n<h2 id=\"使用教程\"><a href=\"#使用教程\" class=\"headerlink\" title=\"使用教程\"></a>使用教程</h2><ol>\n<li>运行『微信Web开发者工具』</li>\n<li>通过微信扫描二维码</li>\n<li>创建项目<ul>\n<li>AppID：随便填</li>\n<li>项目名称：随便填</li>\n<li>本地开发目录：选择一个目录</li>\n</ul>\n</li>\n<li>点击「添加项目」（此时如果出错，先退出再重进就可以了）</li>\n<li>打开项目</li>\n<li>学习里面的quickstart程序</li>\n<li>了解了基本的结构后，可以继续学习demo中的内容（资料下载中含demo源码）</li>\n</ol>\n<p>微信应用号开发底层基于Nodejs，提供了MINA（MINA IS NOT APP）小程序框架，通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生APP体验的服务。<span class=\"exturl\" data-url=\"aHR0cDovL3d4b3Blbi5ub3RlZG93bi5jbi9mcmFtZXdvcmsvTUlOQS5odG1s\">进阶学习请点这<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"使用过程中的问题及解决办法\"><a href=\"#使用过程中的问题及解决办法\" class=\"headerlink\" title=\"使用过程中的问题及解决办法\"></a>使用过程中的问题及解决办法</h2><ol>\n<li><code>Failed to load resource: net::ERR_NAME_NOT_RESOLVED</code><ul>\n<li>问题原因：通常是由于系统设置了代理如Shadowsocks等。</li>\n<li>解决方案：关闭代理，点击微信web开发者工具栏“动作”-“设置”，选择“不使用任何代理，勾选后直连网络”。</li>\n</ul>\n</li>\n<li>console中提示asdebug.js错误<ul>\n<li><code>TypeError: Cannot read property &#39;MaxRequestConcurrent&#39; of undefined</code></li>\n<li>解决方案：替换 <code>/Resources/app.nw/app/dist/weapp/appservice/asdebug.js</code></li>\n</ul>\n</li>\n</ol>\n<p>有图有真相，以下是我亲测后的截图，祝大家好运！希望加QQ群一起交流（260272883）</p>\n<p><img data-src=\"http://ooo.0o0.ooo/2016/09/23/57e4e3fe26b9b.png\" alt=\"截图\"></p>\n","categories":["微信开发"],"tags":["Nodejs","微信应用号","教程"]},{"title":"替换Homebrew国内源","url":"/zh-cn/2017/1/1/%E6%9B%BF%E6%8D%A2Homebrew%E5%9B%BD%E5%86%85%E6%BA%90.html","content":"<p>Homebrew是OS X上类似APT(apt-get)、Yum的一个软件包管理器。 所以，虽然你侥幸下载到了brew，但你肯定是无法更新brew的。原因你懂。不过虽然不能更新brew，但这只是指brew这个管理器本身罢了，软件还是可以安装的。但由于无法使用brew update也就无法更新…<br>** 注意：本方法适合1.1.6版的Homebrew，老版本要用另外的办法（文中有介绍）</p>\n<h2 id=\"检查home-brew的版本\"><a href=\"#检查home-brew的版本\" class=\"headerlink\" title=\"检查home brew的版本\"></a>检查home brew的版本</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew -v</span><br><span class=\"line\">Homebrew 1.1.6</span><br></pre></td></tr></table></figure>\n<p>如果版本低于上述版本，请参阅：<span class=\"exturl\" data-url=\"aHR0cHM6Ly95cS5hbGl5dW4uY29tL2FydGljbGVzLzUwNTU/ZG89bG9naW4=\">这篇文章<i class=\"fa fa-external-link-alt\"></i></span><br>但是，步骤参照上文，仍然是没法成功clone的，因为国内源的地址已经改了，所以对应的源地址要更改为：<br>清华大学镜像源：<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2dpdC9ob21lYnJldy9ob21lYnJldy1jb3JlLmdpdA==\">https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git<i class=\"fa fa-external-link-alt\"></i></span><br>科大镜像源：<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9taXJyb3JzLnVzdGMuZWR1LmNuL2hvbWVicmV3LWNvcmUuZ2l0\">https://mirrors.ustc.edu.cn/homebrew-core.git<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>如果版本是1.1.6及以上，请按照以下办法更新源：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;Homebrew</span><br><span class=\"line\">&#x2F;&#x2F;以下换成清华的源也可以</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-core.git</span><br><span class=\"line\">brew update &#x2F;&#x2F;等待成功喜讯 ：）</span><br></pre></td></tr></table></figure>\n\n<p><strong>enjoy！</strong></p>\n","categories":["实用技巧"],"tags":["Mac"]},{"title":"Linux系统概述","url":"/zh-cn/2020/6/6/yuque/linux%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.html","content":"<h2 id=\"linux-架构层次\"><a href=\"#linux-架构层次\" class=\"headerlink\" title=\"linux 架构层次\"></a>linux 架构层次</h2><p><img data-src=\"https://raw.githubusercontent.com/sampx/resources/master/images/linux_note/99E0F8A8231CEA62B59C55D866A81DE4.jpg#align=left&display=inline&height=835&margin=%5Bobject%20Object%5D&originHeight=835&originWidth=1024&status=done&style=none&width=1024\" alt=\"\"></p>\n<ul>\n<li>用户模式：</li>\n</ul>\n<p>用户程序在用户模式下运行，访问内存和 cpu 有一定限制，用户程序崩溃，不会导致整个系统崩溃，但用户程序也有可能带来严重影响，比如清除硬盘数据，当然这取决于权限的控制。</p>\n<ul>\n<li>内核模式</li>\n</ul>\n<p>内核中的程序运行在内核模式下，内核模式下代码可以不受限制的访问 cpu 和内存，这种模式非常强大但也非常危险，程序出错可以轻易的使整个系统崩溃。</p>\n<ul>\n<li>主内存（也称作内核空间）</li>\n</ul>\n<p>内核和进程在主内存中运行，cpu 像一个操作员一样处理内存中的数据，读取指令和数据，然后计算后将结果写回内存。内核将主内存划分为很多区块，并且维护这些区块的状态，每一个进程拥有自己的内存区块，内核必须确保进程只使用它自己的内存区块。</p>\n<ul>\n<li>用户空间</li>\n</ul>\n<p>用户空间是指所有用户进程占用的所有内存空间，一个进程简单说就是内存中的一个状态。</p>\n<h2 id=\"用户\"><a href=\"#用户\" class=\"headerlink\" title=\"用户\"></a>用户</h2><p>一个用户代表一个实体，它有权限运行用户进程，对文件拥有所有权。<br>内核是通过用户 ID 来管理用户的，用户 ID 是一串数字标识。<br>用户机制主要用于权限管理。每一个用户进程都有一个用户作为所有者，我们称其为以该用户运行的进程。<br>root 用户虽然权限很高，但是还是在用户模式而非内核模式中运行。</p>\n<h2 id=\"内核\"><a href=\"#内核\" class=\"headerlink\" title=\"内核\"></a>内核</h2><p>内核负责管理进程、内存、设备驱动程序和系统调用。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/sampx/resources/master/images/linux_note/53425978C75AF929C50ABBD3141ADEB9.jpg#align=left&display=inline&height=643&margin=%5Bobject%20Object%5D&originHeight=768&originWidth=1024&status=done&style=none&width=857\" alt=\"\"></p>\n<h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2><ul>\n<li>CPU 为每个进程计时，到时即停止进程，并切换至内核模式，由内核接管 CPU 控制权。</li>\n<li>内核记录下当前 CPU 和内存的状态信息，这些信息在恢复被停止的进程时需要用到。</li>\n<li>内核执行上一个时间段内的任务（如从输入输出设备获得数据，磁盘读写操作等）。</li>\n<li>内核准备执行下一个进程，从准备就绪的进程中选择一个执行。</li>\n<li>内核为新进程准备 CPU 和内存。</li>\n<li>内核将新进程执行的时间段通知 CPU。</li>\n<li>内核将 CPU 切换至用户模式，将 CPU 控制权移交给新进程。</li>\n</ul>\n<blockquote>\n<p>注解：内核是在上下文切换时的时间段间隙中运行，在多 CPU 系统中，如果新进程将在另一个 CPU 上运行，内核就不需要让出当前 CPU 的使用权。不过为了将所有 CPU 的使用效率最大化，内核会使用一些其他的方式来获取 CPU 控制权</p>\n</blockquote>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><ul>\n<li>内核在上下文切换过程中管理内存；</li>\n<li>内核需要自己的专有内存空间，其他的用户进程无法访问；</li>\n<li>每个用户进程有自己的专有内存空间；</li>\n<li>一个进程不能访问另一个进程的专有内存空间；</li>\n<li>用户进程之间可以共享内存；</li>\n<li>用户进程的某些内存空间可以是只读的；</li>\n<li>通过使用磁盘交换，系统可以使用比实际内存容量更多的内存空间。</li>\n</ul>\n<blockquote>\n<p>注解：内存地址映射通过内存页面表（page table）来实现。<br>新型的 CPU 提供了 MMU（Memory Management Unit，内存管理单元），MMU 使用了一种叫作虚拟内存的内存访问机制。</p>\n</blockquote>\n<h2 id=\"设备驱动程序和设备管理\"><a href=\"#设备驱动程序和设备管理\" class=\"headerlink\" title=\"设备驱动程序和设备管理\"></a>设备驱动程序和设备管理</h2><ul>\n<li>通常设备只能在内核模式中被访问，例如用户进程请求内核关闭系统电源</li>\n<li>不同设备之间没有一个统一的编程接口，比如两个不同的网卡。</li>\n<li>所以设备驱动程序传统意义上来说是内核的一部分，它们尽可能为用户进程提供统一的接口。</li>\n</ul>\n<h2 id=\"系统调用和系统支持\"><a href=\"#系统调用和系统支持\" class=\"headerlink\" title=\"系统调用和系统支持\"></a>系统调用和系统支持</h2><ul>\n<li>打开、读取和写文件这些操作都涉及系统调用</li>\n<li>两个非常重要的系统调用：fork()和 exec()</li>\n<li>除了 init 以外，Linux 中的所有用户进程都是通过 fork()来启动的。</li>\n</ul>\n<blockquote>\n<p>fork()：当进程调用 fork()时，内核创建一个和该进程几乎一模一样的副本。<br>exec()：当进程调用 exec(program)时，内核启动 program 来替换当前的进程。</p>\n</blockquote>\n<ul>\n<li>新进程的启动流程</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/sampx/resources/master/images/linux_note/BA65AA0FC77C9F12126EE68676DE59CC.jpg#align=left&display=inline&height=370&margin=%5Bobject%20Object%5D&originHeight=370&originWidth=526&status=done&style=none&width=526\" alt=\"\"></p>\n<p>当你在终端窗口中输入 ls 时，终端窗口中的 shell 调用 fork()创建一个 shell 的副本，然后该副本调用 exec(ls)来运行 ls。</p>\n","categories":["linux"],"tags":["linux"]},{"title":"404","url":"/404/index.html","content":"<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"      \n        homePageUrl=\"/\" homePageName=\"Return udock\">\n</script>"},{"title":"About Me","url":"/about/me.html","content":"<h1 id=\"I-am-Samuel\"><a href=\"#I-am-Samuel\" class=\"headerlink\" title=\"I am Samuel\"></a>I am Samuel</h1>"},{"title":"分类","url":"/categories/index.html","content":""},{"title":"mainPage","url":"/mainPage/index.html","content":""},{"title":"标签","url":"/tags/index.html","content":""}]